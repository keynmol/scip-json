// Generated by the Scala Plugin for the Protocol Buffer Compiler.
// Do not edit!
//
// Protofile syntax: PROTO3

package scip.scip

/** Occurrence associates a source position with a symbol and/or highlighting
  * information.
  *
  * If possible, indexers should try to bundle logically related information
  * across occurrences into a single occurrence to reduce payload sizes.
  *
  * @param range
  *   Source position of this occurrence. Must be exactly three or four
  *   elements:
  *  
  *   - Four elements: `[startLine, startCharacter, endLine, endCharacter]`
  *   - Three elements: `[startLine, startCharacter, endCharacter]`. The end line
  *     is inferred to have the same value as the start line.
  *  
  *   Line numbers and characters are always 0-based. Make sure to increment the
  *   line/character values before displaying them in an editor-like UI because
  *   editors conventionally use 1-based numbers.
  *  
  *   Historical note: the original draft of this schema had a `Range` message
  *   type with `start` and `end` fields of type `Position`, mirroring LSP.
  *   Benchmarks revealed that this encoding was inefficient and that we could
  *   reduce the total payload size of an index by 50% by using `repeated int32`
  *   instead.  The `repeated int32` encoding is admittedly more embarrassing to
  *   work with in some programming languages but we hope the performance
  *   improvements make up for it.
  * @param symbol
  *   (optional) The symbol that appears at this position. See
  *   `SymbolInformation.symbol` for how to format symbols as strings.
  * @param symbolRoles
  *   (optional) Bitset containing `SymbolRole`s in this occurrence.
  *   See `SymbolRole`'s documentation for how to read and write this field.
  * @param overrideDocumentation
  *   (optional) CommonMark-formatted documentation for this specific range. If
  *   empty, the `Symbol.documentation` field is used instead. One example
  *   where this field might be useful is when the symbol represents a generic
  *   function (with abstract type parameters such as `List&lt;T&gt;`) and at this
  *   occurrence we know the exact values (such as `List&lt;String&gt;`).
  *  
  *   This field can also be used for dynamically or gradually typed languages,
  *   which commonly allow for type-changing assignment.
  * @param syntaxKind
  *   (optional) What syntax highlighting class should be used for this range?
  * @param diagnostics
  *   (optional) Diagnostics that have been reported for this specific range.
  */
@SerialVersionUID(0L)
final case class Occurrence(
    range: _root_.scala.Seq[_root_.scala.Int] = _root_.scala.Seq.empty,
    symbol: _root_.scala.Predef.String = "",
    symbolRoles: _root_.scala.Int = 0,
    overrideDocumentation: _root_.scala.Seq[_root_.scala.Predef.String] = _root_.scala.Seq.empty,
    syntaxKind: scip.scip.SyntaxKind = scip.scip.SyntaxKind.UnspecifiedSyntaxKind,
    diagnostics: _root_.scala.Seq[scip.scip.Diagnostic] = _root_.scala.Seq.empty,
    unknownFields: _root_.scalapb.UnknownFieldSet = _root_.scalapb.UnknownFieldSet.empty
    ) extends scalapb.GeneratedMessage with scalapb.lenses.Updatable[Occurrence] {
    private[this] def rangeSerializedSize = {
      if (__rangeSerializedSizeField == 0) __rangeSerializedSizeField = {
        var __s: _root_.scala.Int = 0
        range.foreach(__i => __s += _root_.com.google.protobuf.CodedOutputStream.computeInt32SizeNoTag(__i))
        __s
      }
      __rangeSerializedSizeField
    }
    @transient private[this] var __rangeSerializedSizeField: _root_.scala.Int = 0
    @transient
    private[this] var __serializedSizeMemoized: _root_.scala.Int = 0
    private[this] def __computeSerializedSize(): _root_.scala.Int = {
      var __size = 0
      if (range.nonEmpty) {
        val __localsize = rangeSerializedSize
        __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(__localsize) + __localsize
      }
      
      {
        val __value = symbol
        if (!__value.isEmpty) {
          __size += _root_.com.google.protobuf.CodedOutputStream.computeStringSize(2, __value)
        }
      };
      
      {
        val __value = symbolRoles
        if (__value != 0) {
          __size += _root_.com.google.protobuf.CodedOutputStream.computeInt32Size(3, __value)
        }
      };
      overrideDocumentation.foreach { __item =>
        val __value = __item
        __size += _root_.com.google.protobuf.CodedOutputStream.computeStringSize(4, __value)
      }
      
      {
        val __value = syntaxKind.value
        if (__value != 0) {
          __size += _root_.com.google.protobuf.CodedOutputStream.computeEnumSize(5, __value)
        }
      };
      diagnostics.foreach { __item =>
        val __value = __item
        __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
      }
      __size += unknownFields.serializedSize
      __size
    }
    override def serializedSize: _root_.scala.Int = {
      var __size = __serializedSizeMemoized
      if (__size == 0) {
        __size = __computeSerializedSize() + 1
        __serializedSizeMemoized = __size
      }
      __size - 1
      
    }
    def writeTo(`_output__`: _root_.com.google.protobuf.CodedOutputStream): _root_.scala.Unit = {
      if (range.nonEmpty) {
        _output__.writeTag(1, 2)
        _output__.writeUInt32NoTag(rangeSerializedSize)
        range.foreach(_output__.writeInt32NoTag)
      };
      {
        val __v = symbol
        if (!__v.isEmpty) {
          _output__.writeString(2, __v)
        }
      };
      {
        val __v = symbolRoles
        if (__v != 0) {
          _output__.writeInt32(3, __v)
        }
      };
      overrideDocumentation.foreach { __v =>
        val __m = __v
        _output__.writeString(4, __m)
      };
      {
        val __v = syntaxKind.value
        if (__v != 0) {
          _output__.writeEnum(5, __v)
        }
      };
      diagnostics.foreach { __v =>
        val __m = __v
        _output__.writeTag(6, 2)
        _output__.writeUInt32NoTag(__m.serializedSize)
        __m.writeTo(_output__)
      };
      unknownFields.writeTo(_output__)
    }
    def clearRange = copy(range = _root_.scala.Seq.empty)
    def addRange(__vs: _root_.scala.Int *): Occurrence = addAllRange(__vs)
    def addAllRange(__vs: Iterable[_root_.scala.Int]): Occurrence = copy(range = range ++ __vs)
    def withRange(__v: _root_.scala.Seq[_root_.scala.Int]): Occurrence = copy(range = __v)
    def withSymbol(__v: _root_.scala.Predef.String): Occurrence = copy(symbol = __v)
    def withSymbolRoles(__v: _root_.scala.Int): Occurrence = copy(symbolRoles = __v)
    def clearOverrideDocumentation = copy(overrideDocumentation = _root_.scala.Seq.empty)
    def addOverrideDocumentation(__vs: _root_.scala.Predef.String *): Occurrence = addAllOverrideDocumentation(__vs)
    def addAllOverrideDocumentation(__vs: Iterable[_root_.scala.Predef.String]): Occurrence = copy(overrideDocumentation = overrideDocumentation ++ __vs)
    def withOverrideDocumentation(__v: _root_.scala.Seq[_root_.scala.Predef.String]): Occurrence = copy(overrideDocumentation = __v)
    def withSyntaxKind(__v: scip.scip.SyntaxKind): Occurrence = copy(syntaxKind = __v)
    def clearDiagnostics = copy(diagnostics = _root_.scala.Seq.empty)
    def addDiagnostics(__vs: scip.scip.Diagnostic *): Occurrence = addAllDiagnostics(__vs)
    def addAllDiagnostics(__vs: Iterable[scip.scip.Diagnostic]): Occurrence = copy(diagnostics = diagnostics ++ __vs)
    def withDiagnostics(__v: _root_.scala.Seq[scip.scip.Diagnostic]): Occurrence = copy(diagnostics = __v)
    def withUnknownFields(__v: _root_.scalapb.UnknownFieldSet) = copy(unknownFields = __v)
    def discardUnknownFields = copy(unknownFields = _root_.scalapb.UnknownFieldSet.empty)
    def getFieldByNumber(__fieldNumber: _root_.scala.Int): _root_.scala.Any = {
      (__fieldNumber: @_root_.scala.unchecked) match {
        case 1 => range
        case 2 => {
          val __t = symbol
          if (__t != "") __t else null
        }
        case 3 => {
          val __t = symbolRoles
          if (__t != 0) __t else null
        }
        case 4 => overrideDocumentation
        case 5 => {
          val __t = syntaxKind.javaValueDescriptor
          if (__t.getNumber() != 0) __t else null
        }
        case 6 => diagnostics
      }
    }
    def getField(__field: _root_.scalapb.descriptors.FieldDescriptor): _root_.scalapb.descriptors.PValue = {
      _root_.scala.Predef.require(__field.containingMessage eq companion.scalaDescriptor)
      (__field.number: @_root_.scala.unchecked) match {
        case 1 => _root_.scalapb.descriptors.PRepeated(range.iterator.map(_root_.scalapb.descriptors.PInt(_)).toVector)
        case 2 => _root_.scalapb.descriptors.PString(symbol)
        case 3 => _root_.scalapb.descriptors.PInt(symbolRoles)
        case 4 => _root_.scalapb.descriptors.PRepeated(overrideDocumentation.iterator.map(_root_.scalapb.descriptors.PString(_)).toVector)
        case 5 => _root_.scalapb.descriptors.PEnum(syntaxKind.scalaValueDescriptor)
        case 6 => _root_.scalapb.descriptors.PRepeated(diagnostics.iterator.map(_.toPMessage).toVector)
      }
    }
    def toProtoString: _root_.scala.Predef.String = _root_.scalapb.TextFormat.printToUnicodeString(this)
    def companion: scip.scip.Occurrence.type = scip.scip.Occurrence
    // @@protoc_insertion_point(GeneratedMessage[scip.Occurrence])
}

object Occurrence extends scalapb.GeneratedMessageCompanion[scip.scip.Occurrence] {
  implicit def messageCompanion: scalapb.GeneratedMessageCompanion[scip.scip.Occurrence] = this
  def parseFrom(`_input__`: _root_.com.google.protobuf.CodedInputStream): scip.scip.Occurrence = {
    val __range: _root_.scala.collection.immutable.VectorBuilder[_root_.scala.Int] = new _root_.scala.collection.immutable.VectorBuilder[_root_.scala.Int]
    var __symbol: _root_.scala.Predef.String = ""
    var __symbolRoles: _root_.scala.Int = 0
    val __overrideDocumentation: _root_.scala.collection.immutable.VectorBuilder[_root_.scala.Predef.String] = new _root_.scala.collection.immutable.VectorBuilder[_root_.scala.Predef.String]
    var __syntaxKind: scip.scip.SyntaxKind = scip.scip.SyntaxKind.UnspecifiedSyntaxKind
    val __diagnostics: _root_.scala.collection.immutable.VectorBuilder[scip.scip.Diagnostic] = new _root_.scala.collection.immutable.VectorBuilder[scip.scip.Diagnostic]
    var `_unknownFields__`: _root_.scalapb.UnknownFieldSet.Builder = null
    var _done__ = false
    while (!_done__) {
      val _tag__ = _input__.readTag()
      _tag__ match {
        case 0 => _done__ = true
        case 8 =>
          __range += _input__.readInt32()
        case 10 => {
          val length = _input__.readRawVarint32()
          val oldLimit = _input__.pushLimit(length)
          while (_input__.getBytesUntilLimit > 0) {
            __range += _input__.readInt32()
          }
          _input__.popLimit(oldLimit)
        }
        case 18 =>
          __symbol = _input__.readStringRequireUtf8()
        case 24 =>
          __symbolRoles = _input__.readInt32()
        case 34 =>
          __overrideDocumentation += _input__.readStringRequireUtf8()
        case 40 =>
          __syntaxKind = scip.scip.SyntaxKind.fromValue(_input__.readEnum())
        case 50 =>
          __diagnostics += _root_.scalapb.LiteParser.readMessage[scip.scip.Diagnostic](_input__)
        case tag =>
          if (_unknownFields__ == null) {
            _unknownFields__ = new _root_.scalapb.UnknownFieldSet.Builder()
          }
          _unknownFields__.parseField(tag, _input__)
      }
    }
    scip.scip.Occurrence(
        range = __range.result(),
        symbol = __symbol,
        symbolRoles = __symbolRoles,
        overrideDocumentation = __overrideDocumentation.result(),
        syntaxKind = __syntaxKind,
        diagnostics = __diagnostics.result(),
        unknownFields = if (_unknownFields__ == null) _root_.scalapb.UnknownFieldSet.empty else _unknownFields__.result()
    )
  }
  implicit def messageReads: _root_.scalapb.descriptors.Reads[scip.scip.Occurrence] = _root_.scalapb.descriptors.Reads{
    case _root_.scalapb.descriptors.PMessage(__fieldsMap) =>
      _root_.scala.Predef.require(__fieldsMap.keys.forall(_.containingMessage eq scalaDescriptor), "FieldDescriptor does not match message type.")
      scip.scip.Occurrence(
        range = __fieldsMap.get(scalaDescriptor.findFieldByNumber(1).get).map(_.as[_root_.scala.Seq[_root_.scala.Int]]).getOrElse(_root_.scala.Seq.empty),
        symbol = __fieldsMap.get(scalaDescriptor.findFieldByNumber(2).get).map(_.as[_root_.scala.Predef.String]).getOrElse(""),
        symbolRoles = __fieldsMap.get(scalaDescriptor.findFieldByNumber(3).get).map(_.as[_root_.scala.Int]).getOrElse(0),
        overrideDocumentation = __fieldsMap.get(scalaDescriptor.findFieldByNumber(4).get).map(_.as[_root_.scala.Seq[_root_.scala.Predef.String]]).getOrElse(_root_.scala.Seq.empty),
        syntaxKind = scip.scip.SyntaxKind.fromValue(__fieldsMap.get(scalaDescriptor.findFieldByNumber(5).get).map(_.as[_root_.scalapb.descriptors.EnumValueDescriptor]).getOrElse(scip.scip.SyntaxKind.UnspecifiedSyntaxKind.scalaValueDescriptor).number),
        diagnostics = __fieldsMap.get(scalaDescriptor.findFieldByNumber(6).get).map(_.as[_root_.scala.Seq[scip.scip.Diagnostic]]).getOrElse(_root_.scala.Seq.empty)
      )
    case _ => throw new RuntimeException("Expected PMessage")
  }
  def javaDescriptor: _root_.com.google.protobuf.Descriptors.Descriptor = ScipProto.javaDescriptor.getMessageTypes().get(9)
  def scalaDescriptor: _root_.scalapb.descriptors.Descriptor = ScipProto.scalaDescriptor.messages(9)
  def messageCompanionForFieldNumber(__number: _root_.scala.Int): _root_.scalapb.GeneratedMessageCompanion[_] = {
    var __out: _root_.scalapb.GeneratedMessageCompanion[_] = null
    (__number: @_root_.scala.unchecked) match {
      case 6 => __out = scip.scip.Diagnostic
    }
    __out
  }
  lazy val nestedMessagesCompanions: Seq[_root_.scalapb.GeneratedMessageCompanion[_ <: _root_.scalapb.GeneratedMessage]] = Seq.empty
  def enumCompanionForFieldNumber(__fieldNumber: _root_.scala.Int): _root_.scalapb.GeneratedEnumCompanion[_] = {
    (__fieldNumber: @_root_.scala.unchecked) match {
      case 5 => scip.scip.SyntaxKind
    }
  }
  lazy val defaultInstance = scip.scip.Occurrence(
    range = _root_.scala.Seq.empty,
    symbol = "",
    symbolRoles = 0,
    overrideDocumentation = _root_.scala.Seq.empty,
    syntaxKind = scip.scip.SyntaxKind.UnspecifiedSyntaxKind,
    diagnostics = _root_.scala.Seq.empty
  )
  implicit class OccurrenceLens[UpperPB](_l: _root_.scalapb.lenses.Lens[UpperPB, scip.scip.Occurrence]) extends _root_.scalapb.lenses.ObjectLens[UpperPB, scip.scip.Occurrence](_l) {
    def range: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Seq[_root_.scala.Int]] = field(_.range)((c_, f_) => c_.copy(range = f_))
    def symbol: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Predef.String] = field(_.symbol)((c_, f_) => c_.copy(symbol = f_))
    def symbolRoles: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Int] = field(_.symbolRoles)((c_, f_) => c_.copy(symbolRoles = f_))
    def overrideDocumentation: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Seq[_root_.scala.Predef.String]] = field(_.overrideDocumentation)((c_, f_) => c_.copy(overrideDocumentation = f_))
    def syntaxKind: _root_.scalapb.lenses.Lens[UpperPB, scip.scip.SyntaxKind] = field(_.syntaxKind)((c_, f_) => c_.copy(syntaxKind = f_))
    def diagnostics: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Seq[scip.scip.Diagnostic]] = field(_.diagnostics)((c_, f_) => c_.copy(diagnostics = f_))
  }
  final val RANGE_FIELD_NUMBER = 1
  final val SYMBOL_FIELD_NUMBER = 2
  final val SYMBOL_ROLES_FIELD_NUMBER = 3
  final val OVERRIDE_DOCUMENTATION_FIELD_NUMBER = 4
  final val SYNTAX_KIND_FIELD_NUMBER = 5
  final val DIAGNOSTICS_FIELD_NUMBER = 6
  def of(
    range: _root_.scala.Seq[_root_.scala.Int],
    symbol: _root_.scala.Predef.String,
    symbolRoles: _root_.scala.Int,
    overrideDocumentation: _root_.scala.Seq[_root_.scala.Predef.String],
    syntaxKind: scip.scip.SyntaxKind,
    diagnostics: _root_.scala.Seq[scip.scip.Diagnostic]
  ): _root_.scip.scip.Occurrence = _root_.scip.scip.Occurrence(
    range,
    symbol,
    symbolRoles,
    overrideDocumentation,
    syntaxKind,
    diagnostics
  )
  // @@protoc_insertion_point(GeneratedMessageCompanion[scip.Occurrence])
}
