// Generated by the Scala Plugin for the Protocol Buffer Compiler.
// Do not edit!
//
// Protofile syntax: PROTO3

package scip.scip

/** Symbol is similar to a URI, it identifies a class, method, or a local
  * variable. `SymbolInformation` contains rich metadata about symbols such as
  * the docstring.
  *
  * Symbol has a standardized string representation, which can be used
  * interchangeably with `Symbol`. The syntax for Symbol is the following:
  * ```
  * # (&lt;x&gt;)+ stands for one or more repetitions of &lt;x&gt;
  * &lt;symbol&gt;               ::= &lt;scheme&gt; ' ' &lt;package&gt; ' ' (&lt;descriptor&gt;)+ | 'local ' &lt;local-id&gt;
  * &lt;package&gt;              ::= &lt;manager&gt; ' ' &lt;package-name&gt; ' ' &lt;version&gt;
  * &lt;scheme&gt;               ::= any UTF-8, escape spaces with double space.
  * &lt;manager&gt;              ::= same as above, use the placeholder '.' to indicate an empty value
  * &lt;package-name&gt;         ::= same as above
  * &lt;version&gt;              ::= same as above
  * &lt;descriptor&gt;           ::= &lt;namespace&gt; | &lt;type&gt; | &lt;term&gt; | &lt;method&gt; | &lt;type-parameter&gt; | &lt;parameter&gt; | &lt;meta&gt; | &lt;macro&gt;
  * &lt;namespace&gt;            ::= &lt;name&gt; '/'
  * &lt;type&gt;                 ::= &lt;name&gt; '#'
  * &lt;term&gt;                 ::= &lt;name&gt; '.'
  * &lt;meta&gt;                 ::= &lt;name&gt; ':'
  * &lt;macro&gt;                ::= &lt;name&gt; '!'
  * &lt;method&gt;               ::= &lt;name&gt; '(' &lt;method-disambiguator&gt; ').'
  * &lt;type-parameter&gt;       ::= '[' &lt;name&gt; ']'
  * &lt;parameter&gt;            ::= '(' &lt;name&gt; ')'
  * &lt;name&gt;                 ::= &lt;identifier&gt;
  * &lt;method-disambiguator&gt; ::= &lt;simple-identifier&gt;
  * &lt;identifier&gt;           ::= &lt;simple-identifier&gt; | &lt;escaped-identifier&gt;
  * &lt;simple-identifier&gt;    ::= (&lt;identifier-character&gt;)+
  * &lt;identifier-character&gt; ::= '_' | '+' | '-' | '$' | ASCII letter or digit
  * &lt;escaped-identifier&gt;   ::= '`' (&lt;escaped-character&gt;)+ '`'
  * &lt;escaped-characters&gt;   ::= any UTF-8 character, escape backticks with double backtick.
  * ```
  *
  * The list of descriptors for a symbol should together form a fully
  * qualified name for the symbol. That is, it should serve as a unique
  * identifier across the package. Typically, it will include one descriptor
  * for every node in the AST (along the ancestry path) between the root of
  * the file and the node corresponding to the symbol.
  */
@SerialVersionUID(0L)
final case class Symbol(
    scheme: _root_.scala.Predef.String = "",
    `package`: _root_.scala.Option[scip.scip.Package] = _root_.scala.None,
    descriptors: _root_.scala.Seq[scip.scip.Descriptor] = _root_.scala.Seq.empty,
    unknownFields: _root_.scalapb.UnknownFieldSet = _root_.scalapb.UnknownFieldSet.empty
    ) extends scalapb.GeneratedMessage with scalapb.lenses.Updatable[Symbol] {
    @transient
    private[this] var __serializedSizeMemoized: _root_.scala.Int = 0
    private[this] def __computeSerializedSize(): _root_.scala.Int = {
      var __size = 0
      
      {
        val __value = scheme
        if (!__value.isEmpty) {
          __size += _root_.com.google.protobuf.CodedOutputStream.computeStringSize(1, __value)
        }
      };
      if (`package`.isDefined) {
        val __value = `package`.get
        __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
      };
      descriptors.foreach { __item =>
        val __value = __item
        __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
      }
      __size += unknownFields.serializedSize
      __size
    }
    override def serializedSize: _root_.scala.Int = {
      var __size = __serializedSizeMemoized
      if (__size == 0) {
        __size = __computeSerializedSize() + 1
        __serializedSizeMemoized = __size
      }
      __size - 1
      
    }
    def writeTo(`_output__`: _root_.com.google.protobuf.CodedOutputStream): _root_.scala.Unit = {
      {
        val __v = scheme
        if (!__v.isEmpty) {
          _output__.writeString(1, __v)
        }
      };
      `package`.foreach { __v =>
        val __m = __v
        _output__.writeTag(2, 2)
        _output__.writeUInt32NoTag(__m.serializedSize)
        __m.writeTo(_output__)
      };
      descriptors.foreach { __v =>
        val __m = __v
        _output__.writeTag(3, 2)
        _output__.writeUInt32NoTag(__m.serializedSize)
        __m.writeTo(_output__)
      };
      unknownFields.writeTo(_output__)
    }
    def withScheme(__v: _root_.scala.Predef.String): Symbol = copy(scheme = __v)
    def getPackage: scip.scip.Package = `package`.getOrElse(scip.scip.Package.defaultInstance)
    def clearPackage: Symbol = copy(`package` = _root_.scala.None)
    def withPackage(__v: scip.scip.Package): Symbol = copy(`package` = Option(__v))
    def clearDescriptors = copy(descriptors = _root_.scala.Seq.empty)
    def addDescriptors(__vs: scip.scip.Descriptor *): Symbol = addAllDescriptors(__vs)
    def addAllDescriptors(__vs: Iterable[scip.scip.Descriptor]): Symbol = copy(descriptors = descriptors ++ __vs)
    def withDescriptors(__v: _root_.scala.Seq[scip.scip.Descriptor]): Symbol = copy(descriptors = __v)
    def withUnknownFields(__v: _root_.scalapb.UnknownFieldSet) = copy(unknownFields = __v)
    def discardUnknownFields = copy(unknownFields = _root_.scalapb.UnknownFieldSet.empty)
    def getFieldByNumber(__fieldNumber: _root_.scala.Int): _root_.scala.Any = {
      (__fieldNumber: @_root_.scala.unchecked) match {
        case 1 => {
          val __t = scheme
          if (__t != "") __t else null
        }
        case 2 => `package`.orNull
        case 3 => descriptors
      }
    }
    def getField(__field: _root_.scalapb.descriptors.FieldDescriptor): _root_.scalapb.descriptors.PValue = {
      _root_.scala.Predef.require(__field.containingMessage eq companion.scalaDescriptor)
      (__field.number: @_root_.scala.unchecked) match {
        case 1 => _root_.scalapb.descriptors.PString(scheme)
        case 2 => `package`.map(_.toPMessage).getOrElse(_root_.scalapb.descriptors.PEmpty)
        case 3 => _root_.scalapb.descriptors.PRepeated(descriptors.iterator.map(_.toPMessage).toVector)
      }
    }
    def toProtoString: _root_.scala.Predef.String = _root_.scalapb.TextFormat.printToUnicodeString(this)
    def companion: scip.scip.Symbol.type = scip.scip.Symbol
    // @@protoc_insertion_point(GeneratedMessage[scip.Symbol])
}

object Symbol extends scalapb.GeneratedMessageCompanion[scip.scip.Symbol] {
  implicit def messageCompanion: scalapb.GeneratedMessageCompanion[scip.scip.Symbol] = this
  def parseFrom(`_input__`: _root_.com.google.protobuf.CodedInputStream): scip.scip.Symbol = {
    var __scheme: _root_.scala.Predef.String = ""
    var __package: _root_.scala.Option[scip.scip.Package] = _root_.scala.None
    val __descriptors: _root_.scala.collection.immutable.VectorBuilder[scip.scip.Descriptor] = new _root_.scala.collection.immutable.VectorBuilder[scip.scip.Descriptor]
    var `_unknownFields__`: _root_.scalapb.UnknownFieldSet.Builder = null
    var _done__ = false
    while (!_done__) {
      val _tag__ = _input__.readTag()
      _tag__ match {
        case 0 => _done__ = true
        case 10 =>
          __scheme = _input__.readStringRequireUtf8()
        case 18 =>
          __package = Option(__package.fold(_root_.scalapb.LiteParser.readMessage[scip.scip.Package](_input__))(_root_.scalapb.LiteParser.readMessage(_input__, _)))
        case 26 =>
          __descriptors += _root_.scalapb.LiteParser.readMessage[scip.scip.Descriptor](_input__)
        case tag =>
          if (_unknownFields__ == null) {
            _unknownFields__ = new _root_.scalapb.UnknownFieldSet.Builder()
          }
          _unknownFields__.parseField(tag, _input__)
      }
    }
    scip.scip.Symbol(
        scheme = __scheme,
        `package` = __package,
        descriptors = __descriptors.result(),
        unknownFields = if (_unknownFields__ == null) _root_.scalapb.UnknownFieldSet.empty else _unknownFields__.result()
    )
  }
  implicit def messageReads: _root_.scalapb.descriptors.Reads[scip.scip.Symbol] = _root_.scalapb.descriptors.Reads{
    case _root_.scalapb.descriptors.PMessage(__fieldsMap) =>
      _root_.scala.Predef.require(__fieldsMap.keys.forall(_.containingMessage eq scalaDescriptor), "FieldDescriptor does not match message type.")
      scip.scip.Symbol(
        scheme = __fieldsMap.get(scalaDescriptor.findFieldByNumber(1).get).map(_.as[_root_.scala.Predef.String]).getOrElse(""),
        `package` = __fieldsMap.get(scalaDescriptor.findFieldByNumber(2).get).flatMap(_.as[_root_.scala.Option[scip.scip.Package]]),
        descriptors = __fieldsMap.get(scalaDescriptor.findFieldByNumber(3).get).map(_.as[_root_.scala.Seq[scip.scip.Descriptor]]).getOrElse(_root_.scala.Seq.empty)
      )
    case _ => throw new RuntimeException("Expected PMessage")
  }
  def javaDescriptor: _root_.com.google.protobuf.Descriptors.Descriptor = ScipProto.javaDescriptor.getMessageTypes().get(4)
  def scalaDescriptor: _root_.scalapb.descriptors.Descriptor = ScipProto.scalaDescriptor.messages(4)
  def messageCompanionForFieldNumber(__number: _root_.scala.Int): _root_.scalapb.GeneratedMessageCompanion[_] = {
    var __out: _root_.scalapb.GeneratedMessageCompanion[_] = null
    (__number: @_root_.scala.unchecked) match {
      case 2 => __out = scip.scip.Package
      case 3 => __out = scip.scip.Descriptor
    }
    __out
  }
  lazy val nestedMessagesCompanions: Seq[_root_.scalapb.GeneratedMessageCompanion[_ <: _root_.scalapb.GeneratedMessage]] = Seq.empty
  def enumCompanionForFieldNumber(__fieldNumber: _root_.scala.Int): _root_.scalapb.GeneratedEnumCompanion[_] = throw new MatchError(__fieldNumber)
  lazy val defaultInstance = scip.scip.Symbol(
    scheme = "",
    `package` = _root_.scala.None,
    descriptors = _root_.scala.Seq.empty
  )
  implicit class SymbolLens[UpperPB](_l: _root_.scalapb.lenses.Lens[UpperPB, scip.scip.Symbol]) extends _root_.scalapb.lenses.ObjectLens[UpperPB, scip.scip.Symbol](_l) {
    def scheme: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Predef.String] = field(_.scheme)((c_, f_) => c_.copy(scheme = f_))
    def `package`: _root_.scalapb.lenses.Lens[UpperPB, scip.scip.Package] = field(_.getPackage)((c_, f_) => c_.copy(`package` = Option(f_)))
    def optionalPackage: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Option[scip.scip.Package]] = field(_.`package`)((c_, f_) => c_.copy(`package` = f_))
    def descriptors: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Seq[scip.scip.Descriptor]] = field(_.descriptors)((c_, f_) => c_.copy(descriptors = f_))
  }
  final val SCHEME_FIELD_NUMBER = 1
  final val PACKAGE_FIELD_NUMBER = 2
  final val DESCRIPTORS_FIELD_NUMBER = 3
  def of(
    scheme: _root_.scala.Predef.String,
    `package`: _root_.scala.Option[scip.scip.Package],
    descriptors: _root_.scala.Seq[scip.scip.Descriptor]
  ): _root_.scip.scip.Symbol = _root_.scip.scip.Symbol(
    scheme,
    `package`,
    descriptors
  )
  // @@protoc_insertion_point(GeneratedMessageCompanion[scip.Symbol])
}
